{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to kubed-sh , the Kubernetes distributed shell for the casual cluster user. In a nutshell, kubed-sh lets you execute a program in a Kubernetes cluster without having to create a container image or learn new concepts. For example, let's say you have a Node.js script called test.js and you want to launch it as a containerized app in your Kubernetes cluster, here's what you'd need to do in kubed-sh : 1 2 3 4 [ kind :: default ] $ node test . js & [ kind :: default ] $ ps DPID SOURCE URL kubed - sh - 1517679562543558000 test . js test Does this look familiar to what you do in your \"local\" shell? That's the point of kubed-sh : it allows you to use Kubernetes without needing to learn anything new. See it in action: Introducing kubed-sh (5 min) kubed-sh hot-reload feature demo (3 min) In addition to launching (Linux ELF) binaries directly, the following interpreted environments are supported: When you enter node script.js , kubed-sh launches a Node.js (default v12) container, copies the script into it and starts it. When you enter python script.py , kubed-sh launches a Python (default v3.6) container, copies the script into it and starts it. When you enter ruby script.rb , kubed-sh launches a Ruby (default v2.5) container, copies the script into it and starts it. Tip Since kubed-sh is a proper shell environment. This means you can expect features such as auto-complete of built-in commands, history operations ( CTRL+R ), or clearing the screen ( CTRL+L ) to work as per usual. Want to give it a try? Go ahead and install it now!","title":"Home"},{"location":"design/","text":"In the following we discuss the UX concepts of kubed-sh and review its architecture. UX concepts \u00b6 In kubed-sh we're using terms as follows: Cluster : a collection of Kubernetes control plane (master) and node (worker) components ; can be local ( kind for example) or remote such as an EKS cluster. Context : when working with multiple clusters the context helps to pinpoint where exactly operations happen. Technically, a context defines the execution target and is a tuple in the form of: <name,cluster,authinfo,namespace> Environment : a kubed-sh -specific concept describing the current set of resources you're operating on; it is part of a context. Note that environment is an extension of the (*nix local shell) concept of an environment into a set of clusters, located in exactly one Kubernetes namespace. For example, an environment has a list of environment variables and can be used for fine-grained execution control (scripting, project isolation). Environments \u00b6 In kubed-sh you can always tell the execution target by looking at the prompt. The general format of the prompt is as follows: 1 [ environment@context::namespace ] For example: 1 [ example.com@kind::demo ] Above means you're currently in the example.com environment, using the kind context in the demo namespace. Here are the rules: If no environment is explicitly created, the global environment is used. The prompt then changes to [context::namespace] . This is the default at startup. The context can be changed by issuing the built-in use command. The environment can be changed by issuing the built in env command. If the environment name ( $ENV ) is a FQDN and you launch a long-running (background) process called theapp then the resulting underlying service will be exposed to the outside world at $ENV/theapp . Launching programs \u00b6 kubed-sh follows two simple rules that mimic the behavior you're used to from a local shell: If a launch command via a binary or a script with an interpreted environment (initially: support for Node.js, Python, and Ruby) ends with an & , this causes the creation of a deployment and a service (name equals the name of the binary or script); this is good for any long-running app, effectively executing in the background. If the launch command doesn't end in an & then a pod is created; this is good for one-shot batch or interactive apps. Further, kubed-sh supports environment variables to define and overwrite behavior such as the images used, exposed service port, runtime features like hot-reload, etc. Architecture \u00b6 The system architecture of kubed-sh looks as follows: In a nutshell, kubed-sh uses kubectl to launch and control binaries and scripts for you. It is multi-cluster and context aware and supports some local commands (such as cd , ls , cat ) as well as a number of cluster commands, for example ps , kill or curl . First and foremost kubed-sh depends on kubectl for all cluster operations. That is, all remote operations in the cluster essentially cause shelling out to kubectl . You can see what kubectl commands kubed-sh executes when you execute the debug built-in command. To provide the shell interaction we're using the REPL package chzyer/readline , offering autocomplete, search ( CTRL+R ) and other standard operations such as CTRL+L for clearing the screen. kubed-sh is stateless, meaning that any kind of state\u2014such as environment membership, phases or app components\u2014is entirely stored in Kubernetes, using labels and annotations.","title":"Design"},{"location":"design/#ux-concepts","text":"In kubed-sh we're using terms as follows: Cluster : a collection of Kubernetes control plane (master) and node (worker) components ; can be local ( kind for example) or remote such as an EKS cluster. Context : when working with multiple clusters the context helps to pinpoint where exactly operations happen. Technically, a context defines the execution target and is a tuple in the form of: <name,cluster,authinfo,namespace> Environment : a kubed-sh -specific concept describing the current set of resources you're operating on; it is part of a context. Note that environment is an extension of the (*nix local shell) concept of an environment into a set of clusters, located in exactly one Kubernetes namespace. For example, an environment has a list of environment variables and can be used for fine-grained execution control (scripting, project isolation).","title":"UX concepts"},{"location":"design/#environments","text":"In kubed-sh you can always tell the execution target by looking at the prompt. The general format of the prompt is as follows: 1 [ environment@context::namespace ] For example: 1 [ example.com@kind::demo ] Above means you're currently in the example.com environment, using the kind context in the demo namespace. Here are the rules: If no environment is explicitly created, the global environment is used. The prompt then changes to [context::namespace] . This is the default at startup. The context can be changed by issuing the built-in use command. The environment can be changed by issuing the built in env command. If the environment name ( $ENV ) is a FQDN and you launch a long-running (background) process called theapp then the resulting underlying service will be exposed to the outside world at $ENV/theapp .","title":"Environments"},{"location":"design/#launching-programs","text":"kubed-sh follows two simple rules that mimic the behavior you're used to from a local shell: If a launch command via a binary or a script with an interpreted environment (initially: support for Node.js, Python, and Ruby) ends with an & , this causes the creation of a deployment and a service (name equals the name of the binary or script); this is good for any long-running app, effectively executing in the background. If the launch command doesn't end in an & then a pod is created; this is good for one-shot batch or interactive apps. Further, kubed-sh supports environment variables to define and overwrite behavior such as the images used, exposed service port, runtime features like hot-reload, etc.","title":"Launching programs"},{"location":"design/#architecture","text":"The system architecture of kubed-sh looks as follows: In a nutshell, kubed-sh uses kubectl to launch and control binaries and scripts for you. It is multi-cluster and context aware and supports some local commands (such as cd , ls , cat ) as well as a number of cluster commands, for example ps , kill or curl . First and foremost kubed-sh depends on kubectl for all cluster operations. That is, all remote operations in the cluster essentially cause shelling out to kubectl . You can see what kubectl commands kubed-sh executes when you execute the debug built-in command. To provide the shell interaction we're using the REPL package chzyer/readline , offering autocomplete, search ( CTRL+R ) and other standard operations such as CTRL+L for clearing the screen. kubed-sh is stateless, meaning that any kind of state\u2014such as environment membership, phases or app components\u2014is entirely stored in Kubernetes, using labels and annotations.","title":"Architecture"},{"location":"faq/","text":"For whom is kubed-sh ? When to use it? Answer I suppose it's mainly useful in a prototyping, development, or testing phase, although for low-level interactions you might find it handy in prod environments as well since it provides an interactive, context-aware version of kubectl . See also use cases . How is kubed-sh pronounced? Answer Glad you asked. Well, I pronounce it /ku:b\u02c8d\u00e6\u0283/ as in 'kube dash' ;) Why another Kubernetes shell? There are already some, such as cloudnativelabs/kube-shell , errordeveloper/kubeplay , and c-bata/kube-prompt . Why write another Kubernetes shell, are they not cool or what? Answer True, there is previous art, though these shells more or less aim at making kubectl interactive, exposing the commands such as get or apply to the user. In a sense kubed-sh is more like technosophos/kubeshell , trying to provide an environment a typical *nix user is comfortable with. For example, rather than providing a create or apply command to run a program, the user would simply enter the name of the executable, as she would do, for example, in the bash shell. See also the motivation . How does kubed-sh work? Answer Essentially it's just a glorified kubectl wrapper on steroids. See also the architecture section.","title":"FAQ"},{"location":"install/","text":"In order to be able to install and use kubed-sh you must meet two prerequisites: kubectl must be installed , tested with client version up to and included 1.17 . Access to a Kubernetes cluster must be configured, tested with up to 1.14 . Tip To verify your setup, you can use the following two steps: Execute ls ~/.kube/config > /dev/null && echo $? and if you see a 0 as a result, you're good, and further Execute kubectl config get-contexts | wc -l and if you see a number greater than 0 , then that's super dope. To install and set up kubed-sh , simply download the latest binary for Linux and macOS. For example, to install kubed-sh from binary on macOS you could do the following: 1 2 3 4 5 curl -L https://github.com/mhausenblas/kubed-sh/releases/latest/download/kubed-sh_darwin_amd64.tar.gz \\ -o kubed-sh.tar.gz && \\ tar xvzf kubed-sh.tar.gz kubed-sh && \\ mv kubed-sh /usr/local/bin && \\ rm kubed-sh* Now you're good to go, learn how to use kubed-sh \u2026","title":"Install"},{"location":"motivation/","text":"While Kubernetes is a very powerful, flexible, and extensible environment to run applications, it can also be quite overwhelming, especially for casual users. This effectively means there's a barrier to entry for developers. Three issues motivated me to write kubed-sh in the first place: 1. the number of Kubernetes primitives one needs to learn in order to use it, 2. lack of interactivity of existing tools, and 3. the need to build/push/pull container images. You can read more about this topic in As We May Kube or have a quick look here: Learning curve: primitives \u00b6 Kubernetes introduces a number of primitives such as pods, deployments, and services. These form the building blocks for the applications you deploy and run. Now, without having at least a basic familiarity with the workloads, networking, and storage concepts it's hard to figure when to use what and how to combine things. Some platforms, such as OpenShift, help here by hiding certain complex primitives and making it easier for the casual user, however oftentimes certain resource types, such as pods or services still are present and the user needs to be knowledgeable around them, nevertheless. When coming from single-machine operating system such as Linux, you're already familiar with certain primitives such as processes, files, and job management in the shell. Put in other words, in order to execute a, say, Python script, you only need to know how to type python thescript.py , without studying Linux kernel structures first. Lack of interactivity \u00b6 For many folks the go-to tool for interacting with a Kubernetes cluster on the command line to date is still kubectl . While there are number of tools available that make your life easier, not many are interactive and/or offer a fully functional shell environment. Container image build drag \u00b6 In order to launch an application, you first need a container image that Kubernetes in turn can run, then. There are multiple options to create a container image, from using a CI/CD pipeline to specialized build processes such as S2I to local builds and manual pushes. One can also use off-the-shelf images, launch them and then use tools like Telepresence or ksync to transfer the application code into the running container. In any case, one has to deal with images, directly and explicitly. Wouldn't it be nice if that task is automagically done for you?","title":"Motivation"},{"location":"motivation/#learning-curve-primitives","text":"Kubernetes introduces a number of primitives such as pods, deployments, and services. These form the building blocks for the applications you deploy and run. Now, without having at least a basic familiarity with the workloads, networking, and storage concepts it's hard to figure when to use what and how to combine things. Some platforms, such as OpenShift, help here by hiding certain complex primitives and making it easier for the casual user, however oftentimes certain resource types, such as pods or services still are present and the user needs to be knowledgeable around them, nevertheless. When coming from single-machine operating system such as Linux, you're already familiar with certain primitives such as processes, files, and job management in the shell. Put in other words, in order to execute a, say, Python script, you only need to know how to type python thescript.py , without studying Linux kernel structures first.","title":"Learning curve: primitives"},{"location":"motivation/#lack-of-interactivity","text":"For many folks the go-to tool for interacting with a Kubernetes cluster on the command line to date is still kubectl . While there are number of tools available that make your life easier, not many are interactive and/or offer a fully functional shell environment.","title":"Lack of interactivity"},{"location":"motivation/#container-image-build-drag","text":"In order to launch an application, you first need a container image that Kubernetes in turn can run, then. There are multiple options to create a container image, from using a CI/CD pipeline to specialized build processes such as S2I to local builds and manual pushes. One can also use off-the-shelf images, launch them and then use tools like Telepresence or ksync to transfer the application code into the running container. In any case, one has to deal with images, directly and explicitly. Wouldn't it be nice if that task is automagically done for you?","title":"Container image build drag"},{"location":"use/","text":"Once you've kubed-sh installed, launch it and you should find yourself in an interactive shell: 1 2 3 4 5 6 7 $ kubed-sh Note: It seems you ' re running kubed-sh in a non-Linux environment ( detected: darwin ) , so make sure the binaries you launch are Linux binaries in ELF format. Detected Kubernetes client in version v1.17.2 and server in version v1.14.9-eks-c0eccc [ user@somecluster.eu-west-1.eksctl.io::demo ] $ Above, you notice that on start-up kubed-sh will tell you which client and server version of Kubernetes it has detected and at any point in time you are able to tell in which context you're working (here: user@somecluster.eu-west-1.eksctl.io ) as well in which namespace (here: demo ) you're operating. Learn more \u2026 Built-ins \u00b6 In general kubed-sh tries to behave like a normal/local shell such as Bash. For example, if an input (or line in a script) starts with an # it's considered a comment and hence ignored. There are however some cases where kubed-sh differs significantly from a local shell: the execution of what we call distributed processes. If you launch such a distributed process, either via entering the name of a Linux binary or via one of the supported interpreted languages (Node.js, Python, Ruby), then under the hood and transparently to you kubed-sh creates Kubernetes resources in the target cluster (namespace). Keep this in mind when you see the scope of a command; if it says cluster that's a hint that under the hood some kubectl voodoo is going on. Commands \u00b6 The built-in commands of kubed-sh (see also help ) are as follows: command scope description cat local output the content of file to terminal cd local change working directory curl cluster execute a curl operation in the cluster contexts local list available Kubernetes contexts debug local toggle debug mode (detailed info printed) echo local print a value or environment variable env local see below exit local exit kubed-sh help local list built-in commands; use help command for details kill cluster stop a distributed process literally local literally execute as a kubectl command ls local list content of directory ps cluster list all distributed processes in current environment pwd local print current working directory sleep local sleep for specified time interval (a NOP) use cluster select a Kubernetes context to work with version local print kubed-sh version Tip Rather than the lengthy literally simply prefix a line with ` to achieve the same. For example, if you enter `get po you list the pods in the current namespace. The env command (which, on its own lists kubed-sh environment variables ) has four sub-commands: env list \u2026 list all defined environments in current context env create $ENVNAME \u2026 create a new environment called $ENVNAME env select $ENVNAME \u2026 make environment called $ENVNAME the active one env delete $ENVNAME \u2026 delete environment called $ENVNAME If no environment is selected, you are operating in the global environment. Note When you execute the env delete ENVNAME command, the environment is reaped and all the distributed processes go back into the global environment. Environment variables \u00b6 In kubed-sh you can define and use your own environments . Within an environment, there are a number of pre-defined environment variables, which influence the creation of the distributed processes: BINARY_IMAGE (default: alpine:3.7 ) \u2026 for executing binaries NODE_IMAGE (default: node:12-alpine ) \u2026 for executing Node.js scripts PYTHON_IMAGE (default: python:3.6-alpine3.7 ) \u2026 for executing Python scripts RUBY_IMAGE (default: ruby:2.5-alpine3.7 ) \u2026 for executing Ruby scripts SERVICE_PORT (default: 80 ) \u2026 expose long-running process on this port (in-cluster) SERVICE_NAME (default: \"\" ) \u2026 overwrite URL of long-running process (in-cluster) HOTRELOAD (default: false ) \u2026 enable a watch on local files to trigger automatic updates on modification (EXPERIMENTAL) Tip You can overwrite any of the above environment variables to change the runtime behavior of the distributed processes you create. All changes are valid for the runtime of kubed-sh . That is, when you quit kubed-sh all pre-defined environment variables are reset to their default values. Run-time configuration \u00b6 kubed-sh understands the following environment variables. You have to define them in the parent shell (such as bash) to influence the runtime behavior of kubed-sh : environment variable default set to \u2026 KUBEDSH_DEBUG false print detailed debug messages KUBEDSH_PREPULL false pre-pull images via DaemonSet KUBECTL_BINARY use which kubectl use this binary for API server communication Tip If you want to speed up the time-to-first-launch, set KUBEDSH_PREPULL=true and kubed-sh will create a DaemonSet , causing all supported languages to be ready for use. Given the nature of a DaemonSet this is available in all Kubernetes environments that explicitly allow for node access. For example, you can not use this feature in EKS on Fargate or OpenShift Online, where nodes as such are not visible or accessible. Modes \u00b6 You can use kubed-sh either interactively or in script mode. In script mode, you provide kubed-sh a script file to interpret or make it executable\u2014for example using chmod 755 thescript along with a hashbang header. The following example illustrates using kubed-sh in script mode. Imagine you have a script file called test.kbdsh with the following content: 1 2 3 4 5 #! / usr / bin / env kubed - sh use user @somecluster . eu - west - 1. eksctl . io # This line is a comment that will be ignored node .. / thescript . js & ps Then, you can make it executable and execute it like so: 1 2 $ chmod 755 test.kbdsh $ ./test.kbdsh Alternatively you can provide a script via stdin : 1 $ cat tc/script.kbdsh | kubed-sh \u2026 or as a command line argument: 1 $ kubed-sh tc/script.kbdsh As an aside, all three above shown ways to launch a script are in fact equivalent.","title":"Use"},{"location":"use/#built-ins","text":"In general kubed-sh tries to behave like a normal/local shell such as Bash. For example, if an input (or line in a script) starts with an # it's considered a comment and hence ignored. There are however some cases where kubed-sh differs significantly from a local shell: the execution of what we call distributed processes. If you launch such a distributed process, either via entering the name of a Linux binary or via one of the supported interpreted languages (Node.js, Python, Ruby), then under the hood and transparently to you kubed-sh creates Kubernetes resources in the target cluster (namespace). Keep this in mind when you see the scope of a command; if it says cluster that's a hint that under the hood some kubectl voodoo is going on.","title":"Built-ins"},{"location":"use/#commands","text":"The built-in commands of kubed-sh (see also help ) are as follows: command scope description cat local output the content of file to terminal cd local change working directory curl cluster execute a curl operation in the cluster contexts local list available Kubernetes contexts debug local toggle debug mode (detailed info printed) echo local print a value or environment variable env local see below exit local exit kubed-sh help local list built-in commands; use help command for details kill cluster stop a distributed process literally local literally execute as a kubectl command ls local list content of directory ps cluster list all distributed processes in current environment pwd local print current working directory sleep local sleep for specified time interval (a NOP) use cluster select a Kubernetes context to work with version local print kubed-sh version Tip Rather than the lengthy literally simply prefix a line with ` to achieve the same. For example, if you enter `get po you list the pods in the current namespace. The env command (which, on its own lists kubed-sh environment variables ) has four sub-commands: env list \u2026 list all defined environments in current context env create $ENVNAME \u2026 create a new environment called $ENVNAME env select $ENVNAME \u2026 make environment called $ENVNAME the active one env delete $ENVNAME \u2026 delete environment called $ENVNAME If no environment is selected, you are operating in the global environment. Note When you execute the env delete ENVNAME command, the environment is reaped and all the distributed processes go back into the global environment.","title":"Commands"},{"location":"use/#environment-variables","text":"In kubed-sh you can define and use your own environments . Within an environment, there are a number of pre-defined environment variables, which influence the creation of the distributed processes: BINARY_IMAGE (default: alpine:3.7 ) \u2026 for executing binaries NODE_IMAGE (default: node:12-alpine ) \u2026 for executing Node.js scripts PYTHON_IMAGE (default: python:3.6-alpine3.7 ) \u2026 for executing Python scripts RUBY_IMAGE (default: ruby:2.5-alpine3.7 ) \u2026 for executing Ruby scripts SERVICE_PORT (default: 80 ) \u2026 expose long-running process on this port (in-cluster) SERVICE_NAME (default: \"\" ) \u2026 overwrite URL of long-running process (in-cluster) HOTRELOAD (default: false ) \u2026 enable a watch on local files to trigger automatic updates on modification (EXPERIMENTAL) Tip You can overwrite any of the above environment variables to change the runtime behavior of the distributed processes you create. All changes are valid for the runtime of kubed-sh . That is, when you quit kubed-sh all pre-defined environment variables are reset to their default values.","title":"Environment variables"},{"location":"use/#run-time-configuration","text":"kubed-sh understands the following environment variables. You have to define them in the parent shell (such as bash) to influence the runtime behavior of kubed-sh : environment variable default set to \u2026 KUBEDSH_DEBUG false print detailed debug messages KUBEDSH_PREPULL false pre-pull images via DaemonSet KUBECTL_BINARY use which kubectl use this binary for API server communication Tip If you want to speed up the time-to-first-launch, set KUBEDSH_PREPULL=true and kubed-sh will create a DaemonSet , causing all supported languages to be ready for use. Given the nature of a DaemonSet this is available in all Kubernetes environments that explicitly allow for node access. For example, you can not use this feature in EKS on Fargate or OpenShift Online, where nodes as such are not visible or accessible.","title":"Run-time configuration"},{"location":"use/#modes","text":"You can use kubed-sh either interactively or in script mode. In script mode, you provide kubed-sh a script file to interpret or make it executable\u2014for example using chmod 755 thescript along with a hashbang header. The following example illustrates using kubed-sh in script mode. Imagine you have a script file called test.kbdsh with the following content: 1 2 3 4 5 #! / usr / bin / env kubed - sh use user @somecluster . eu - west - 1. eksctl . io # This line is a comment that will be ignored node .. / thescript . js & ps Then, you can make it executable and execute it like so: 1 2 $ chmod 755 test.kbdsh $ ./test.kbdsh Alternatively you can provide a script via stdin : 1 $ cat tc/script.kbdsh | kubed-sh \u2026 or as a command line argument: 1 $ kubed-sh tc/script.kbdsh As an aside, all three above shown ways to launch a script are in fact equivalent.","title":"Modes"},{"location":"usecases/","text":"If you have access to a Kubernetes cluster and you have kubectl installed, you're good to go. You might want to consider using kubed-sh , for example for: Prototyping \u2014Let's say you quickly want to try out a Python script or, in the context of microservices, see how a Go program and a Node.js script play together. Developing \u2014Imagine you're developing a program in Ruby and want to launch it in a Kubernetes cluster, without having to build an image and pushing it to a registry. In this case, the experimental hot-reload feature (using HOTRELOAD=true ) is useful for you. Whenever you save the file locally, it gets updated in the Kubernetes cluster, if hot-reload is enabled. Learning Kubernetes \u2014You're new to Kubernetes and want to learn how to interact with it? Tip: if you issue the debug command you can see which kubectl commands kubed-sh launches in the background. Also, you may be interested in my motivation for writing kubed-sh ?","title":"Use Cases"}]}